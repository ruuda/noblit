
<!DOCTYPE html>
<html>
<head>
  <!--
    Kilsbergen MkDocs theme copyright 2019 Ruud van Asseldonk.
    Licensed under the Apache 2.0 license.
    See https://github.com/ruuda/kilsbergen.
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bug tracker — Noblit</title>
  <link href="https://rsms.me/inter/inter.css?v=3.3" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500" rel="stylesheet">
  <style>
  /* The Inter font family, see https://rsms.me/inter.
     https://rsms.me/inter/#faq-cdn suggests that linking these files directly is fine.
  */
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Regular.woff2?v=3.3") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Regular.woff?v=3.3") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  italic;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Italic.woff2?v=3.3") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Italic.woff?v=3.3") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 500;
    src: url("https://rsms.me/inter/font-files/Inter-Medium.woff2?v=3.3") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Medium.woff?v=3.3") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 600;
    src: url("https://rsms.me/inter/font-files/Inter-SemiBold.woff2?v=3.3") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-SemiBold.woff?v=3.3") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 700;
    src: url("https://rsms.me/inter/font-files/Inter-Bold.woff2?v=3.3") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Bold.woff?v=3.3") format("woff");
  }
  /* Modular scale with exponent 1.26, about 2^(1/3), so we get 2em in there,
     which is convenient. 1.26 is also close to (golden ratio)^0.5.
     0.63em
     0.80em
     1.00em
     1.26em
     1.59em
     2.00em
  */
  * { margin: 0; padding: 0; border-spacing: 0; }
  html {
    font-family: Inter, Roboto, sans-serif;
    /* Turn on character variant 8 for Inter, which puts serifs on the uppercase I. */
    font-feature-settings: 'cv08' 1;
    font-size: 16px;
    line-height: 1.59em;
    background-color: #fff;
    min-height: 100%;
    position: relative;
  }
  body {
    /* Tricks to make the sidebar full-height on short pages. */
    position: absolute;
    height: 100%;
    width: 100%;
  }
  #content {
    max-width: 66rem;
    margin-left: auto;
    margin-right: auto;
    position: relative;
    color: #333;
    min-height: 100%;
  }
  #main {
    margin-left: 18em;
    margin-right: 2em;
    padding: 2rem;
    overflow: hidden;
  }
  #breadcrumbs {
    margin-bottom: 2.85rem;
    word-spacing: 0.3em;
    color: #78a;
  }
  #breadcrumbs a {
    word-spacing: 0;
    color: #78a;
  }
  article {
    margin-top: 1.3rem;
  }
  h1, h2, h3 {
    font-weight: 600;
    font-size: 1rem;
    color: #444;
    margin-bottom: 1.59rem;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 1.9rem;
  }
  h2 {
    font-size: 1.59rem;
    margin-top: 3.38rem;
    margin-bottom: 1.39rem;
  }
  code {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.84rem;
    line-height: 1.59rem;
  }
  .mono {
    font-family: 'Roboto Mono', monospace;
  }
  abbr {
    text-transform: uppercase;
    /* Downsize so caps are x-height, and compensate weight loss. */
    font-size: 0.78rem;
    font-weight: 500;
    letter-spacing: 0.05rem;
  }
  sub, sup {
    /* Don't disturb the line height of normal text. */
    line-height: 0rem;
    font-size: 0.78rem;
    font-weight: 500;
  }
  p > code,
  a > code,
  h3 > code,
  li > code,
  td > code {
    background-color: #f0f0f0;
    padding: 0.13rem;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
    border-radius: 0.2rem;
    line-height: 1rem;
  }
  h3 {
    margin-top: 2.29rem;
    margin-bottom: 0.89rem;
  }
  h3 > code {
    margin-left: -0.1rem;
  }
  a {
    color: #36d;
    text-decoration: none;
  }
  p, ul, ol, pre, table {
    /* Same space as line height, leave exactly one line blank. */
    margin-bottom: 1.59em;
  }
  pre {
    padding: 1.41rem;
    padding-right: 0;
    background-color: #f8f8f8;
    border-radius: 0 0.2rem 0.2rem 0;
    border-left: 0.3rem solid #d5d8e0;
    overflow-x: auto;
  }
  pre > code {
    margin-right: 1.41rem;
    color: #555;
  }
  ul, ol {
    list-style-type: none;
    counter-reset: item;
  }
  table {
    font-variant-numeric: tabular-nums;
  }
  th, td {
    padding-right: 2rem;
  }
  th {
    text-align: left;
  }
  #main ul li:before {
    color: #555;
    content: '\2022';
    display: inline-block;
    font-weight: 700;
    margin-left: -0.9rem;
    width: 0.9rem;
  }
  #main ul li {
    margin-left: 0.87rem;
  }
  #main ol li:before {
    content: counter(item);
    display: inline-block;
    font-weight: 700;
    width: 0.8rem;
    margin-left: -1.6rem;
    padding-right: 0.8rem;
  }
  #main ol li {
    margin-left: 1.6rem;
    counter-increment: item;
  }
  #nav-prev-next {
    margin-top: 3.18rem;
    padding-bottom: 3.18rem;
  }
  #nav-prev, #nav-next, #repo-link {
    display: inline-block;
  }
  #nav-prev {
    float: left;
  }
  #nav-next, #repo-link {
    float: right;
    text-align: right;
  }
  #nav-prev::before {
    content: '\219e';
    padding-right: 0.5em;
  }
  #nav-next::after {
    content: '\21a0';
    padding-left: 0.5em;
  }
  aside {
    position: absolute;
    top: 0;
    left: -84em;
    width: 100em;
    border-right: 1px solid #eee;
    background-color: #fafafa;
    height: 100%;
  }
  aside nav {
    margin-top: 8.4rem;
    margin-bottom: 3rem;
    width: 14rem;
    float: right;
    /* Put the active chapter border over the sidebar border. */
    margin-right: -1px;
  }
  aside a {
    color: #78a;
  }
  aside .toc-section {
    font-weight: 700;
  }
  aside ul {
    margin-bottom: 0;
  }
  aside li ul {
    /* This padding destroys the vertical rhythm,
       but I somehow feel it is necessary. */
    padding-top: 0.3rem;
    padding-bottom: 0.4rem;
  }
  aside li.toc-section {
    padding-top: 1.59rem;
  }
  aside li.toc-section a {
    color: #36d;
  }
  aside li.current, aside li ul {
    border-right: 0.3em solid #d5d8e0;
    padding-left: 1em;
    margin-left: -1em;
  }
  aside .current a {
    font-weight: 600;
  }
  aside .current.mono a, h3 > code {
    /* Roboto Mono 500 is about as heavy as Inter semibold (600). */
    font-weight: 500;
  }
  aside li.toc-heading {
    padding-left: 1em;
  }

  @media(max-width: 1150px)
  {
    html { font-size: 15px; }
  }

  /* Move the sidebar TOC below content at small widths. */
  @media(max-width: 800px)
  {
    aside {
      position: relative;
      top: 0;
      left: 0;
      width: 100%;
      height: auto;
      border-top: 1px solid #eee;
      border-right: 0px none;
      overflow: hidden;
    }
    aside nav {
      margin-left: 4em;
      margin-top: 1.59em;
      float: none;
    }
    #main {
      margin-left: 2em;
      padding-bottom: 1.59em;
    }
    aside li.current, aside li ul {
      border-right: 0px none;
    }
  }

  /* Use less generous margins for very narrow viewports. */
  @media(max-width: 650px)
  {
    #main {
      margin-left: 0;
      margin-right: 0;
    }
    aside nav {
      margin-left: 2em;
      margin-bottom: 1.59em;
    }
  }

  @media(max-width: 450px)
  {
    #main {
      padding-left: 1.59em;
      padding-right: 1.59em;
    }
    aside nav {
      margin-left: 1.59em;
    }
  }
  </style>
</head>
<body>
  <div id="content">
    <div id="main">
      <nav id="breadcrumbs">
        <a href="../..">Noblit</a>
        › <a href="../..">Examples</a>
  › <a href="./">Bug tracker</a>
  <a id="repo-link" href="https://github.com/ruuda/noblit/">GitHub</a>
      </nav>
      <article>
        <h1 id="bug-tracker-example">Bug Tracker Example</h1>
<p><em>Note: This example is completely hypothetical, constructed to explore syntax
and requirements. You cannot actually run these queries.</em></p>
<p>Suppose we would want to build a database for a bug tracker, where users can
file and comment on issues, and set and change certain properties. This is an
excellent use case for an immutable database: we want to record status changes
as new facts, but never lose historic data.</p>
<h2 id="schema-and-initial-provisioning">Schema and Initial Provisioning</h2>
<p>We start by setting up attributes to define the schema, similar to how we would
issue <code>CREATE TABLE</code> statements in a SQL database. Unlike in SQL, schema is
reified in Noblit. This means that the schema is data, and it can be manipulated
using the same query language as domain data.</p>
<pre><code>where
  $string_t db.type.name "string"
  $uint64_t db.type.name "uint64"
  $ref_t    db.type.name "ref"

define
  attribute($a, $name, $type, $unique, $many):
    $a db.attribute.name $name
    $a db.attribute.type $type
    $a db.attribute.unique $unique
    $a db.attribute.many $many

assert
  attribute($user_name,         "user.name",         $string_t, true,  false)
  attribute($issue_title,       "issue.title",       $string_t, true,  false)
  attribute($issue_description, "issue.description", $string_t, false, false)
  attribute($issue_priority,    "issue.priority",    $uint64_t, false, false)
  attribute($issue_author,      "issue.author",      $ref_t,    false, false)
  attribute($issue_comment,     "issue.comment",     $ref_t,    true,  false)
  attribute($comment_content,   "comment.content",   $string_t, false, false)
  attribute($comment_author,    "comment.author",    $ref_t,    false, false)

where
  -- Lookp up the data types by name, so we can refer to these types when
  -- defining new attributes.
  $string_t db.type.name "string"
  $uint64_t db.type.name "uint64"
  $ref_t    db.type.name "ref"

assert
  -- Note: these definitions are verbose. Noblit's query language does not
  -- offer abstractions such as functions to reduce verbosity. Rather, you
  -- can build abstractions on top of a client library. Because Noblit has
  -- a simple data model, and because Noblit accepts data structures rather
  -- than strings as queries, it is easy and safe to build such abstractions
  -- in your programming language, rather than into the query language.

  $author_name db.attribute.name   "author.name"
  $author_name db.attribute.type   $string_t
  $author_name db.attribute.unique true
  $author_name db.attribute.many   false

  $issue_title db.attribute.name   "issue.title"
  $issue_title db.attribute.type   $string_t
  $issue_title db.attribute.unique true
  $issue_title db.attribute.many   false

  $issue_description db.attribute.name   "issue.description"
  $issue_description db.attribute.type   $string_t
  $issue_description db.attribute.unique false
  $issue_description db.attribute.many   false

  $issue_priority db.attribute.name   "issue.priority"
  $issue_priority db.attribute.type   $uint64_t
  $issue_priority db.attribute.unique false
  $issue_priority db.attribute.many   false

  $issue_author db.attribute.name   "issue.author"
  $issue_author db.attribute.type   $ref_t
  $issue_author db.attribute.unique false
  $issue_author db.attribute.many   false
  -- Experimental idea: attribute constraints (like foreign keys).
  -- The author ref must point to an entity that has the "author.name"
  -- attribute.
  $issue_author db.constraint.has_attribute $author_name

  $comment_content db.attribute.name   "comment.content"
  $comment_content db.attribute.type   $string_t
  $comment_content db.attribute.unique false
  $comment_content db.attribute.many   false

  $comment_author db.attribute.name   "comment.author"
  $comment_author db.attribute.type   $ref_t
  $comment_author db.attribute.unique false
  $comment_author db.attribute.many   false
  $comment_author db.constraint.has_attribute author_name

  -- TODO: Add created date_time_offset to issue and comment.

  -- Finally, an issue can have multiple comments associated with it. We
  -- could model this relation in two ways: by giving the comment a
  -- "comment.issue" attribute, or by giving the issue an "issue.comment"
  -- attribute. For the sake of demonstration we will go with the latter.
  -- Note that because Noblit maintains an (attribute, entity, value) index
  -- as well as an (attribute, value, entity) index, finding all comments
  -- associated with an issue is efficient in any case.
  $issue_comment db.attribute.name   "issue.comment"
  $issue_comment db.attribute.type   $ref_t
  $issue_comment db.attribute.unique false
  -- We set "many" to true: an issue can have many comments; the attribute
  -- may be present zero or more times.
  $issue_comment db.attribute.many true
  $issue_comment db.constraint.has_attribute $author_name

select
  $issue_title, $issue_description, $issue_priority, $issue_author
</code></pre>
<p>This will set up thee kinds of entities: authors, issues, and comments. These
kinds are only encoded in the attribute names, there are no tables like in a
traditional database. The attribute ids of <code>issue.title</code>, <code>issue.description</code>,
<code>issue.priority</code>, and <code>issue.author</code> will be returned.</p>
<p>Let's insert some initial data:</p>
<pre><code>assert
  $batty author.name "Roy Batty"

  $i issue.title "Lifespan is too short"
  $i issue.description "Can the maker repair what he makes? I want more life."
  $i issue.priority 0
  $i issue.author $batty

select
  $i
</code></pre>
<p>Now we have one issue. The query returns the entity id of the issue. Let's close
the issue as wontfix. But wait a mintue ... we forgot to add a status attribute!
Let's define one right now.</p>
<pre><code>where
  $string_t db.type.name "string"
  $ref_t    db.type.name "ref"
assert
  -- Define an enum for statuses, by defining a single "status.name"
  -- attribute that must have a unique value among all instances of this
  -- attribute.
  $status_name db.attribute.name   "status.name"
  $status_name db.attribute.type   $string_t
  $status_name db.attribute.unique true
  $status_name db.attribute.many   false

  -- Then we define the issue statuses. We reference the new attribute by
  -- variable here. It could not be referenced by name, because at the time
  -- the query is constructed, it does not yet exist.
  $open_unconfirmed $status_name "open/unconfirmed"
  $open_confirmed   $status_name "open/confirmed"
  $open_in_progress $status_name "open/in-progress"
  $closed_fixed     $status_name "closed/fixed"
  $closed_obsolete  $status_name "closed/obsolete"
  $closed_wontfix   $status_name "closed/wont-fix"

  -- Finally, an issue can have a status.
  $issue_status  db.attribute.name   "issue.status"
  $issue_status  db.attribute.type   $ref_t
  $issue_status  db.attribute.unique false
  $issue_status  db.attribute.many   false
  $issue_comment db.constraint.has_attribute $status_name
</code></pre>
<p>Note that at this point, although she <code>issue.status</code> attribute exists, our first
issue does not have the attribute. TODO: How to deal with implied attributes?
(Sort of like non-nullable, except that there is no null in Noblit, only the
presence or absence of an attribute.) Add a constraint that <code>issue.title</code>
implies <code>issue.status</code> (and the others)? And then we'd be forced to add a status
to all issues that don't have one in the same transaction that adds the
attribute. In any case, let's set the issue to open/confirmed. We could
reference the issue and status by entity id directly, but for demonstration
purposes, we will look it up by title instead. We marked the <code>issue.title</code> and
<code>status.name</code> attributes are unique, so this will affect at most one entity.</p>
<pre><code>where
  $issue issue.title "Lifespan is too short"
  $open status.name "open/confirmed"
assert
  $issue issue.status $open
</code></pre>
<p>Now we can close the issue. Note that because the <code>issue.status</code> attribute has
its cardinality <code>attribute.many</code> set to false, we can't just assert a new
status. We also have to retract the old status. The change is atomic, in one
transaction.</p>
<pre><code>where
  $i issue.title "Lifespan is too short"
  $i issue.status $old_status
  $wontfix status.name "closed/wont-fix"

retract
  $i issue.status $old_status

assert
  $tyrell author.name "Eldon Tyrell"

  $c comment.content "The light that burns twice as bright burns half as long."
  $c comment.author $tyrell

  $i issue.comment $c
  $i issue.status $wontfix
</code></pre>
<h2 id="a-selection-of-selects">A Selection of Selects</h2>
<p>Suppose we wanted to list all issues, ordered by priority:</p>
<pre><code>where
  $i issue.title $title
  $i issue.priority $p
select
  $i, $p, $title
order by
  $p asc
</code></pre>
<p>This will return triples of issue entity id, priority, and title, ordered by
priority (supposing we took lower integers to indicate more urgent issues).</p>
<p>TODO: How to filter on only open issues? Would need an <code>in</code> or <code>or</code> clause.</p>
<p>Suppose we wanted to list all issues created by Roy Batty:</p>
<pre><code>where
  $batty author.name "Roy Batty"
  $i issue.author $batty
  $i issue.title $title
select
  $i, $title
</code></pre>
<p>Now we get the entity ids of the issues created by Roy, as well as their titles.</p>
<p>Suppose we want to find all issues where Rick Deckard left a comment:</p>
<pre><code>where
  $deckard author.name "Rick Deckard"
  $c comment.author $deckard
  $i issue.comment $c
  $i issue.title $title
select
  $i, $title
</code></pre>
<p>We again get all issues and titles. We will get a cartesian product of issues
and comments by Deckard though: if Deckard commented twice, the issue will be in
the result set twice. TODO: How to address that? <code>select unique</code>? Or more
fine-grained control? Or just order by the result and uniq it in the client
library?</p>
<h2 id="querying-history">Querying History</h2>
<p>After our issue was created, the status changed from <code>open/unfonfirmed</code> to
<code>closed/wont-fix</code>. However, if we query just the status, we can only see the
current status. The query</p>
<pre><code>where
  $i issue.title "Lifespan is too short"
  $i issue.status $status
select
  $status
</code></pre>
<p>returns <code>closed/wont-fix</code>. If we wanted to construct a timeline of the status
changes that the issue underwent, we could include historic datoms like so:</p>
<pre><code>where
  $i issue.title "Lifespan is too short"
where historic
  $i issue.status $prev_status $t retract
  $i issue.status $new_status $t assert
select
  $t, $prev_status, $new_status
order by
  $t asc
</code></pre>
<p>In a regular <code>where</code> query, only datoms that have not been retracted will match.
A <code>where historic</code> query works differently: it queries <em>all</em> datoms, and it
matches both assertions and retractons alike. To filter these, a historical
query takes 5-tuples rather than 3-tuples. In addition to (entity, attribute,
value), the query takes a transaction id and operation (assert or retract). In
this case, we select <code>prev_status</code> and <code>new_status</code>, such that the status
<code>prev_status</code> was retracted on issue <code>i</code> in transaction <code>t</code>, and <code>new_status</code>
was asserted in the same transaction. This gets us a list of status changes,
ordered by transaction id.</p>
<p>Note that the query to locate the issue by title is not in a <code>where historic</code>
clause. If it were, we would get the status changes of all issues that had been
called <em>Lifespan too short</em> a t some point, not only the history of the issue
that currently has that title.</p>
<p>Transactions in Noblit are reified. They are entities that can have attributes.
Suppose we had added a <code>transaction.date_time_offset</code> attribute to every
transaction, and also a <code>transaction.initiator</code>. Then we could also find out
<em>when</em> the attribute changed, and <em>who</em> made that change.</p>
<pre><code>where
  $i issue.title "Lifespan is too short"
where historic
  $i issue.status $prev_status $t retract
  $i issue.status $new_status $t assert
where
  $t transaction.date_time_offset $time
  $t transaction.initiator $initiator
  $initiator author.name $initiator_name
select
  $time, $initiator_name, $prev_status, $new_status
order by
  $time asc, $t asc
</code></pre>
<p>Now we get a nice chronological list of status changes, along with the name of
the user who made the change.</p>
<p>TODO: Rename <code>author.name</code> to <code>user.name</code>?
TODO: Add section define transaction attributes.</p>
      </article>
      <nav id="nav-prev-next">
        <a id="nav-prev" href="../../query-planning/" title="Query planning">Previous</a>
        <a id="nav-next" href="../../building/" title="Building">Next</a>
        </nav>
      </div>
    <aside>
      <nav>
        <ul>
        <li class="toc-section"><a href="../..">Overview</a></li>
          <li class="toc-section"><a href="../../data-model/">Concepts</a></li>
          <li class="toc-chapter
              "><a href="../../data-model/">Data model</a></li>
            <li class="toc-chapter
              "><a href="../../query/">Query</a></li>
            <li class="toc-chapter
              "><a href="../../query-planning/">Query planning</a></li>
            <li class="toc-section"><a href="./">Examples</a></li>
          <li class="toc-chapter
               current"><a href="./">Bug tracker</a></li>
            <li><ul>
                <li class="toc-heading"><a href="#schema-and-initial-provisioning">Schema and Initial Provisioning</a></li>
                <li class="toc-heading"><a href="#a-selection-of-selects">A Selection of Selects</a></li>
                <li class="toc-heading"><a href="#querying-history">Querying History</a></li>
                </ul></li>
               <li class="toc-section"><a href="../../building/">Development</a></li>
          <li class="toc-chapter
              "><a href="../../building/">Building</a></li>
            <li class="toc-chapter
              "><a href="../../golden-tests/">Golden tests</a></li>
            <li class="toc-chapter
              "><a href="../../resources/">Resources</a></li>
            <li class="toc-section"><a href="../../files/">Internals</a></li>
          <li class="toc-chapter
              "><a href="../../files/">Files</a></li>
            <li class="toc-chapter
              "><a href="../../htree/">Trees</a></li>
            <li class="toc-chapter
              "><a href="../../execution/">Execution</a></li>
            </ul>
      </nav>
    </aside>
  </div>
</body>
</html>
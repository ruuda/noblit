-- A query is a statement about variables.
-- The query engine finds all possible assignments to all free variables,
-- for which the statement is true.
-- Values are exposed to the select part, which indicates what to fetch.
-- Below attributes act as getter functions, similar to record fields in Haskell.
-- E.g. "artist.name ?x" refers to the value of the "artist.name" attribute on
-- entity ?x.

where artist.name ?x == "Muse"
select artist.name ?x

-- Return (track number, track title, duration, album title) for all tracks by Muse.
where
  artist.name ?muse == "Muse"
  album.artist ?album == ?muse
  track.album ?track == ?album
select
  track.number ?track, track.title ?track, track.duration ?track, album.title ?album

-- Variables are not necessarily entity ids. In fact, the latter would be simpler
-- (albeit more verbose), because selects only refer to variables.

-- List all albums by Muse and U2:
where
  artist.name ?muse in ["Muse", "U2"]
  album.artist ?album == ?muse
  album.title ?album == ?album_title
select
  ?album_title

-- You can do graph-like queries and self-joins, although not unboundedly.

-- Select all files nested 3 directories deep under the root directory:
where
  directory.name ?root_dir == "/"
  directory.parent ?sub1 == ?root_dir
  directory.parent ?sub2 == ?sub1
  directory.parent ?sub3 == ?sub2
  file.parent ?file == ?sub3
  ?file_name == file.name ?file
  ?file_size == file.size ?file
select
  ?file, ?file_name, ?file_size
  
-- Some things I'd like for Hoff:

-- All activitiy in the last 30 days:
where
  pr.created ?pr is_after '2018-11-01'
  ?title = pr.title ?pr
  ?number = pr.number ?pr
  ?commit = pr.commit ?pr
  ?status = pr.status ?pr
select
  ?pr, ?number, ?title, ?commit, ?status
order by
  ?number

-- A query plan for the above query (disregarding sort):
for eid in AVET (attr, min_value) .. (attr, infty) {
  for aid in (pr.title, pr.number, pr.commit, pr.status) {
    value = lookup (eid, aid) in EAVT
    yield value
  }
}

-- All approved commits pull requests that are still open:
where
  pr.status ?pr = "open"
  approval.pr ?ap = ?pr
  approval.commit ?ap = pr.commit ?ap
  ?number = pr.number ?pr
  ?title = pr.title ?pr
  ?approved_by = approval.approver ?ap
select
  ?pr, ?number, ?title, ?approved_by
order by
  ?number

-- A query plan for the above query (disregarding sort):
for pr in AVET (pr.status, "open", min) .. (pr.status, "open", max) {
  pr_commit = lookup (pr, pr.commit) in EAVT
  for ap in AVET (approval.pr, pr, min) .. (approval.pr, pr, max) {
    ap_commit = lookup (ap, approval.pr) in EAVT
    if pr_commit != ap_commit { continue }
    number = lookup (pr, pr.number) in EAVT
    title = lookup (pr, pr.title) in EAVT
    approved_by = lookup (ap, approval.approver) in EAVT
    yield pr, number, title, approved_by
}

-- All approved commits for which no integration into the most recent master has
-- been attempted:
where
  pr.status ?pr = "open"
  approval.pr ?ap = ?pr -- Redundant, commits should be central.
  approval.commit ?ap = pr.commit ?ap
where not
  master.commit _ = ?master_rev -- Entity with this attribute should be unique.
  merge.base ?merge = ?master_rev
  merge.tip ?merge = pr.commit ?pr
select
  ?pr

-- A query plan for the above query (disregarding sort):
for pr in AVET (pr.status, "open", min) .. (pr.status, "open", max) {
  pr_commit = lookup (pr, pr.commit) in EAVT
  for ap in AVET (approval.pr, pr, min) .. (approval.pr, pr, max) {
    ap_commit = lookup (ap, approval.pr) in EAVT
    if pr_commit != ap_commit { continue }

    -- TODO: Take advantage of entity uniqueness.
    for datom in AEVT (master.commit, min) .. (master.commit, max) {
      for merge in AVET (merge.base, datom.value, min) .. (merge.base, datom.value, max) {
        merge_tip = lookup (merge, merge.tip) in EAVT
        if merge_commit == pr_commit {
          continue ap loop
        }
      }
    }

    yield pr
}

-- All approved commits for which integration into the most recent master branch
-- has failed:
where
  pr.status ?pr = "open"
  approval.pr ?ap = ?pr
  approval.commit ?ap = pr.commit ?ap
  master.commit _ = ?master_rev
  merge.base ?merge = ?master_rev
  merge.tip ?merge = pr.commit ?pr
  merge.success ?merge = false
select
  pr.number ?pr, pr.title ?pr
order by
  pr.number ?pr

-- All approved commits that can be merged successfully into the most recent
-- master, which we have not yet attempted to push.
where
  pr.status ?pr = "open"
  approval.pr ?ap = ?pr
  approval.commit ?ap = pr.commit ?ap
  master.commit _ = ?master_rev
  merge.base ?merge = ?master_rev
  merge.tip ?merge = pr.commit ?pr
  merge.success ?merge = true
where not
  push.commit _ = merge.commit ?merge
select
  pr.branch ?pr, merge.commit ?pr
order by
  pr.number ?pr

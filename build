#!/usr/bin/env -S python3 tools/run_build.py

# This build file defines some steps that can by executed with ./build <step>.
# The steps get executed by build.py. This file is similar to a makefile in the
# sense that it defines commands to run, but build.py does not track
# dependencies between targets, it only runs the commands.

build_lib:
  cargo build
  cargo test

build_client_haskell:
  cd client/haskell
  stack --no-terminal build
  stack --no-terminal test

build_example_haskell:
  cd examples
  stack --no-terminal build

typecheck:
  # Typecheck Python code.
  mypy --strict client/python
  mypy --strict golden
  mypy --strict libnoblit
  mypy --strict tools

build_header:
  # Generate the C header, then compile it to a precompiled header with GCC.
  # This acts as a basic sanity check on the documentation.
  libnoblit/gen_header.py --output noblit.h
  gcc -Wall -Werror -c noblit.h

check_symbols:
  # Check that all exported symbols are documented, and that all documented
  # symbols are exported.
  libnoblit/check_symbols.py target/debug/libnoblit.so

check_goldens:
  prove --exec golden/run.py golden

build_docs:
  # Build the documentation. This checks for dead links etc.
  mkdocs build

build_miri:
  # Run the Rust test suite under Miri to detect certain classes of undefined
  # behavior. TODO: Also run the binaries and golden tests under Miri. There
  # are two blockers for this:
  # * Miri does not support selecting a binary (https://github.com/rust-lang/miri/issues/739)
  # * Noblit assumes that Vec<u8> is 8-byte aligned. This assumption has so far
  #   not been violated in practice, but in theory the assumption is invalid.
  cd noblit
  cargo +nightly-2020-01-18 clean
  cargo +nightly-2020-01-18 miri test
  cargo +nightly-2020-01-18 clean

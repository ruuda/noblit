-- Third attempt at queries, this time more Datalog-like.

where
  push.sha(P, Sha)
  build.sha(B, Sha)
  build.status(B, "pending")
  push.message(P, Message)
  push.branch(P, Branch)
order by
  P asc, Sha desc
select
  Sha, Branch, Message

-- Or with a less cluttered syntax, focussing on (entity, attribute, value):
where
  p push.sha sha
  b build.sha sha
  b build.status "pending"
  p push.message message
  p push.branch branch
  p push.author author
order by
  p asc, sha desc
select
  sha, branch, message, author

-- Or with a predicate, and separate commit entities:
let
  p pending :- p push.sha sha, b build.sha sha, b build.status "pending"
where
  p pending
  p push.sha sha
  p push.branch branch
  c commit.sha sha
  c commit.message message
  c commit.author message
order by
  p asc, sha desc
select
  sha, branch, message, author

-- All approved commits for which merging into the most recent master has failed:
where
  p pr.status "open"
  p pr.commit commit
  a approval.commit commit
  a approval.pr p -- Redundant, commits should be central.
  _ master.commit master_rev
  m merge.base master_rev
  m merge.tip commit
  m merge.status "failed"
select
  p, *p, master_rev

-- All approved commits for which no integration into the most recent master has
-- been attempted. The "not attempted" is expressed as, "for each merge that
-- involves this commit as the tip, the merge base is not the current master".
where
  p pr.status "open"
  p pr.commit commit
  a approval.commit commit
  a approval.pr p -- Redundant, commits should be central.
  m merge.tip commit
  m merge.base master_rev
  not r master.commit master_rev
select
  p, *p

-- Alternatively, we could switch the role of "merge" and "master" in the
-- previous query. Then we express "not attempted" as "for each merge with the
-- current master as base, this commit is not the tip of the merge".
where
  p pr.status "open"
  p pr.commit commit
  a approval.commit commit
  a approval.pr p -- Redundant, commits should be central.
  r master.commit master_rev
  m merge.base master_rev
  not m merge.tip commit
select
  p, *p

-- In the previous queries, an interesting question arises: how many answers are
-- there? If not all free variables are used for the select part, then the inner
-- loops can produce the same tuple many times. Would this need to be deduplicated?
-- Is this something that the user must choose?

-- Select all attributes from the database:
where
  a db.attribute.name _
select
  a, *a

-- Select all types from the database:
where
  t db.type.name _
select
  t, *t

-- Note that I've been using this *var notation above to indicate "select all
-- attributes". It is a bit awkward: it is a special case, it doesn't fit the
-- syntax well, and its usage from programs is problematic too, because you
-- can't tell from the query structure how many columns will be returned, so it
-- will be hard to make a type-safe API for this. An alternative would be to
-- allow variable attributes. Type safety would still be hard, because the type
-- of a variable can now vary, so a query can no longer be typechecked.

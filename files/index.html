
<!DOCTYPE html>
<html>
<head>
  <!--
    Kilsbergen MkDocs theme copyright 2019 Ruud van Asseldonk.
    Licensed under the Apache 2.0 license.
    See https://github.com/ruuda/kilsbergen.
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Files — Noblit</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500" rel="stylesheet">
  <style>
  /* The Inter font family, see https://rsms.me/inter.
     https://rsms.me/inter/#faq-cdn suggests that linking these files directly is fine.
  */
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Regular.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Regular.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  italic;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Italic.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Italic.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 500;
    src: url("https://rsms.me/inter/font-files/Inter-Medium.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Medium.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 600;
    src: url("https://rsms.me/inter/font-files/Inter-SemiBold.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-SemiBold.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 700;
    src: url("https://rsms.me/inter/font-files/Inter-Bold.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Bold.woff?v=3.11") format("woff");
  }
  /* Modular scale with exponent 1.7^(1/3). The 1.7 was chosen as the line hight
     that goes well with Inter. Previously I used 1.59, but it was just too tight.
     0.59em
     0.70em
     1.00em
     1.19em
     1.42em
     1.70em
     2.02em
     2.42em
  */
  * { margin: 0; padding: 0; border-spacing: 0; }
  html {
    font-family: Inter, Roboto, sans-serif;
    /*
    Turn on character variant 8 for Inter, which puts serifs on the uppercase I.
    Also turn on variant 1, which has a curved 1.
    Disable contextual alternates for now. There is a bug, either in Inter or
    in Chrome (https://crbug.com/1046095) that causes colons after a <strong> to
    be raised above the baseline.
    */
    font-feature-settings: 'cv01' 1, 'cv08' 1, 'calt' 0;

    font-size: 16px;
    line-height: 1.7em;
    background-color: #fff;
    height: 100%;
  }
  body {
    height: 100%;
  }
  #content {
    display: grid;
    grid-template-columns: auto 16rem 50rem auto;
    color: #333;
    min-height: 100%;
  }
  #main {
    grid-area: 1 / 3 / 2 / 4;
    padding: 2.2rem;
    padding-left: 4rem;
    padding-right: 4rem;
    overflow: hidden;
  }
  #breadcrumbs {
    margin-bottom: 3rem;
    word-spacing: 0.3em;
    color: #78a;
  }
  #breadcrumbs a {
    word-spacing: 0;
    color: #78a;
  }
  article {
    margin-top: 1.3rem;
  }
  h1, h2, h3 {
    font-weight: 600;
    font-size: 1rem;
    color: #444;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 2.1rem;
  }
  h2 {
    font-size: 1.42rem;
    margin-top: 3.5rem;
    margin-bottom: 1.6rem;
  }
  code {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.84rem;
    line-height: 1.5rem;
  }
  h3 > code {
    /* Roboto Mono 500 is about as heavy as Inter semibold (600). */
    font-weight: 500;
  }
  abbr {
    text-transform: uppercase;
    /* Downsize so caps are x-height, and compensate weight loss. */
    font-size: 0.78rem;
    font-weight: 500;
    letter-spacing: 0.05rem;
    /* Prevent abbrs from changing the line height of lines in which they occur. */
    line-height: 0;
  }
  sub, sup {
    /* Don't disturb the line height of normal text. */
    line-height: 0rem;
    font-size: 0.78rem;
    font-weight: 500;
  }
  p > code,
  a > code,
  h3 > code,
  li > code,
  td > code,
  dt > code {
    background-color: #f0f0f0;
    padding: 0.13rem;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
    border-radius: 0.2rem;
    line-height: 1rem;
  }
  h3 {
    padding-top: 0.9rem;
    padding-bottom: 0.8rem;
  }
  h3 > code {
    margin-left: -0.1rem;
  }
  a {
    color: #36d;
    text-decoration: none;
  }
  p, ul, ol, dl, pre, table {
    /* Same space as line height, leave exactly one line blank. */
    margin-bottom: 1.7rem;
  }
  pre {
    padding-top: 0.8rem;
    padding-bottom: 0.9rem;
    padding-left: 1.19rem;
    padding-right: 0;
    background-color: #f8f8f8;
    border-radius: 0 0.2rem 0.2rem 0;
    border-left: 0.3rem solid #d5d8e0;
    overflow-x: auto;
  }
  pre > code {
    margin-right: 1.41rem;
    color: #555;
  }
  ul, ol {
    list-style-type: none;
    counter-reset: item;
  }
  table {
    font-variant-numeric: tabular-nums;
  }
  th, td {
    padding-right: 2rem;
  }
  th {
    text-align: left;
  }
  td > img {
    display: block;
    padding-top: 1em;
    padding-bottom: 1em;
  }
  dl {
    display: grid;
    grid-template-columns: 1fr 4fr;
    grid-column-gap: 2em;
  }
  dl dt {
    text-align: right;
  }
  #main ul li:before {
    color: #555;
    content: '\2022';
    display: inline-block;
    font-weight: 700;
    margin-left: -0.9rem;
    width: 0.9rem;
  }
  #main ul li {
    margin-left: 0.87rem;
  }
  #main ol li:before {
    content: counter(item);
    display: inline-block;
    font-weight: 700;
    width: 0.8rem;
    margin-left: -1.6rem;
    padding-right: 0.8rem;
  }
  #main ol li {
    margin-left: 1.6rem;
    counter-increment: item;
  }
  #nav-prev-next {
    margin-top: 3.4rem;
    padding-bottom: 3.3rem;
  }
  #nav-prev, #nav-next, #repo-link {
    display: inline-block;
  }
  #nav-prev {
    float: left;
  }
  #nav-next, #repo-link {
    float: right;
    text-align: right;
  }
  #nav-prev::before {
    content: '\219e';
    padding-right: 0.5em;
  }
  #nav-next::after {
    content: '\21a0';
    padding-left: 0.5em;
  }
  aside {
    grid-area: 1 / 1 / 2 / 3;
    border-right: 1px solid #eee;
    background-color: #fafafa;
    color: #78a;
  }
  aside nav {
    margin-top: 9rem;
    padding-bottom: 3.4rem;
    width: 14rem;
    float: right;
    /* Put the active chapter border over the sidebar border. */
    margin-right: -1px;
  }
  aside a {
    color: inherit;
  }
  aside .toc-section {
    font-weight: 700;
  }
  aside ul {
    margin-bottom: 0;
  }
  aside li ul {
    padding-top: 0.6rem;
    padding-bottom: 1.1rem;
  }
  aside li.toc-section {
    margin-top: 1.7rem;
  }
  aside li.toc-section {
    color: #36d;
  }
  aside li.current, aside li ul {
    border-right: 0.3em solid #d5d8e0;
    padding-left: 1em;
    margin-left: -1em;
  }
  aside li.toc-chapter.current {
    font-weight: 600;
  }
  aside li.toc-heading {
    padding-left: 1em;
  }

  @media(max-width: 63rem)
  {
    #content {
      /* Manual implementation of max-width: on narrower viewports,
         auto-size the body. */
      grid-template-columns: 0 16rem auto 0;
    }
  }

  @media(max-width: 1150px)
  {
    html { font-size: 15px; }
  }

  /* Move the sidebar TOC below content at small widths. */
  @media(max-width: 800px)
  {
    #content {
      display: block;
    }
    aside {
      border-top: 1px solid #eee;
      border-right: 0px none;
      padding-top: 1.7em;
    }
    aside nav {
      margin-left: 4em;
      margin-top: 1.7em;
      margin-right: 0;
      float: none;
      width: auto;
    }
    #main {
      padding-bottom: 1.7em;
    }
    /* Now that the TOC is full-width, adding the border on the right to
       highlight the active page is not as clear anymore, it can be far away.
       The current chapter is still in boldface, but that does not work for
       section indexes. So point a guillemet at it as well. */
    aside li.current, aside li ul {
      border-right: 0px none;
      position: relative;
    }
    aside li.current:before {
      content: '\203a';
      position: absolute;
      left: 0;
    }
  }

  /* Use less generous margins for very narrow viewports. */
  @media(max-width: 650px)
  {
    #main {
      padding-left: 2rem;
      padding-right: 2rem;
    }
    aside nav {
      margin-left: 2rem;
      padding-bottom: 2rem;
    }
  }

  @media(max-width: 450px)
  {
    #main {
      padding-left: 1.7em;
      padding-right: 1.7em;
    }
    aside nav {
      margin-left: 1.7em;
    }
  }
  </style>
</head>
<body>
  <div id="content">
    <div id="main">
      <nav id="breadcrumbs">
        <a href="..">Noblit</a>
         › <a href="./">Internals</a> 
         › <a href="./">Files</a> 
        <a id="repo-link" href="https://github.com/ruuda/noblit/">GitHub</a>
      </nav>
      <article>
        <h1 id="files">Files</h1>
<p><em>Vaporware warning: much of the content below is hypothetical. Currently Noblit
does not persist anything to disk at all.</em></p>
<p>Noblit stores thee kinds of data on disk:</p>
<ul>
<li><a href="#the-heap">The <em>heap</em></a> of large values (integers larger than 62 bits, and
   byte strings longer than 7 bytes).</li>
<li><a href="#the-indexes">The <em>indexes</em></a> that store datoms in sorted order.</li>
<li><a href="#the-head">The <em>head</em></a> with the most recent tree roots, and id counters.</li>
</ul>
<h2 id="accretion">Accretion</h2>
<p>Because Noblit is an append-only database, transactions only add new datoms.
Datoms are only stored in indexes (the indexes are <em>covering</em>), but they may
reference large values on the heap. Indexes are trees that consist of nodes. The
indexes are persistent data structures, in the sense that data is immutable once
written, but we can construct a new index that shares most of its nodes with a
previous version. The index file is an append-only collection of nodes. The head
points to the latest roots of the index trees, and it stores the counters for
allocating entity ids. The head is the only part of Noblit that is updated
in place, the other files are append-only.</p>
<p>Committing a transaction is a three-stage process:</p>
<ol>
<li>Append any new large values to the heap file, and sync the heap.</li>
<li>Add datoms to the indexes. This produces one or more new tree nodes per
    index. Append the new nodes to the index file, and sync it.</li>
<li>Write the new head, and sync it.</li>
</ol>
<p>By making the head update atomic, the entire transaction becomes atomic. If the
commit fails at some point before the new head is written, the old head is still
valid, and it points to valid data. New data may have been appended, but that
data is not yet referenced.</p>
<h2 id="the-indexes">The Indexes</h2>
<p>The indexes in Noblit store datoms in sorted order. There are three indexes:</p>
<ul>
<li><strong>Eavt</strong>: sorted by entity, attribute, value, and transaction.</li>
<li><strong>Aevt</strong>: sorted by attribute, entity, value, and transaction.</li>
<li><strong>Avet</strong>: sorted by attribute, value, entity, and transaction.</li>
</ul>
<p>See also <a href="https://docs.datomic.com/cloud/query/raw-index-access.html">Datomic's index documentation</a>, which formed the
inspiration for Noblit. Note that unlike Datomic, Noblit does not have a Vaet
(value, attribute, entity, transaction) index. This is because attributes in
Noblit are strongly typed. A query such as “list all attributes that this entity
has” is impossible to express in Noblit, because the values associated with the
attribute may not have the same type.</p>
<p>Each index stores all datoms in full. A datom is 32 bytes. Small values are
stored inline in the datom, large values (integers larger than 62 bits and byte
strings longer than 7 bytes) are stored on the value heap, with the datom
containing the index into the value heap.</p>
<p>Noblit stores indexes as <a href="../htree/">hitchhiker trees</a>, a variation on immutable
B-trees which reduces write amplification. Noblit accumulates new datoms in
memory first. At the end of a transaction it flushes those at once to the disk
as new tree nodes, which may share child nodes with the previous tree. To
prevent unreachable nodes from accumulating, trees need to be compacted
occasionally though a copying garbage collection process. Unreachable nodes
are not recycled to ensure immutability of written files: new data is only ever
appended at the end. This simplifies caching.</p>
<h2 id="the-head">The Head</h2>
<p>For every index, the head stores the page id of the root of the tree for that
index. Furthermore, the head stores the counters for id allocation.</p>
<p>TODO: The head should store the size of the index file and heap file, so that it
can truncate them after a failed transaction.</p>
<h2 id="the-heap">The Heap</h2>
<p>The heap is a file that contains <em>large values</em>: integers larger than 62 bytes
and byte strings longer than 7 bytes. Because Noblit is an append-only database
that never removes data, storing a value on the heap is a simple bump-pointer
allocation; the heap only grows.</p>
<p>The heap stores two kinds of values:</p>
<ul>
<li>64-bit integers which don't fit into 62 bytes. They are stored as-is, in 8
   bytes, big endian. (TODO: It should be little endian.)</li>
<li>Byte strings longer than 7 bytes. Note that e.g. strings are also stored as
   byte strings; it is the schema that specifies that those bytes should be
   interpreted as a <abbr>UTF-8</abbr> encoded string. Byte strings are
   length-prefixed with a 64-bit length. The address of a byte string is the
   offset of its length prefix, so its data can be found at the offset 8 bytes
   higher.</li>
</ul>
<p>Values on the value heap are aligned to 8 bytes.</p>
<p>The heap is not checksummed. (Nor the indexes for that matter.) If you do not
trust your storage medium, use a file system or virtual block device that can
detect and report integrity problems.</p>
<p>The value heap might store duplicates. Because values are immutable once stored,
deduplication is safe. If a Datom contains a value that already exists on the
heap, it is safe to reference the existing value, rather than storing it again
on the heap. Noblit may do this, but identifying duplicates is not free, hence
Noblit may store the same value twice.</p>
<p>TODO: Persist a hash table of values too, to identify duplicates? Not really,
can read heap at startup, although that does not scale, persistent hash table
may be needed.</p>
      </article>
      <nav id="nav-prev-next">
        <a id="nav-prev" href="../resources/" title="Resources">Previous</a>
        <a id="nav-next" href="../htree/" title="Trees">Next</a>
        </nav>
      </div>
    <aside>
      <nav>
        <ul>
        <li class="toc-section"><a href="..">Overview</a></li>
          <li class="toc-section
            "><a href="../data-model/">Concepts</a></li>
          
            <li class="toc-chapter
              "><a href="../data-model/">Data model</a></li>
            
            <li class="toc-chapter
              "><a href="../query/">Query</a></li>
            
            <li class="toc-chapter
              "><a href="../query-planning/">Query planning</a></li>
            <li class="toc-section
            "><a href="../examples/bug-tracker/">Examples</a></li>
          
            <li class="toc-chapter
              "><a href="../examples/bug-tracker/">Bug tracker</a></li>
            <li class="toc-section
            "><a href="../reference/rust/">Reference</a></li>
          
            <li class="toc-chapter
              "><a href="../reference/rust/">Rust API reference</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/c/">C API reference</a></li>
            <li class="toc-section
            "><a href="../building/">Development</a></li>
          
            <li class="toc-chapter
              "><a href="../building/">Building</a></li>
            
            <li class="toc-chapter
              "><a href="../golden-tests/">Golden tests</a></li>
            
            <li class="toc-chapter
              "><a href="../fuzz-tests/">Fuzz tests</a></li>
            
            <li class="toc-chapter
              "><a href="../resources/">Resources</a></li>
            <li class="toc-section
            "><a href="./">Internals</a></li>
          
            <li class="toc-chapter
               current"><a href="./">Files</a></li>
            <li><ul>
                <li class="toc-heading"><a href="#accretion">Accretion</a></li>
                <li class="toc-heading"><a href="#the-indexes">The Indexes</a></li>
                <li class="toc-heading"><a href="#the-head">The Head</a></li>
                <li class="toc-heading"><a href="#the-heap">The Heap</a></li>
                </ul></li>
               
            <li class="toc-chapter
              "><a href="../htree/">Trees</a></li>
            
            <li class="toc-chapter
              "><a href="../execution/">Execution</a></li>
            
            <li class="toc-chapter
              "><a href="../query-optimization/">Query optimization</a></li>
            </ul>
      </nav>
    </aside>
  </div>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <!--
    Kilsbergen MkDocs theme copyright 2019 Ruud van Asseldonk.
    Licensed under the Apache 2.0 license.
    See https://github.com/ruuda/kilsbergen.
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Query optimization — Noblit</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500" rel="stylesheet">
  <style>
  /* The Inter font family, see https://rsms.me/inter.
     https://rsms.me/inter/#faq-cdn suggests that linking these files directly is fine.
  */
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Regular.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Regular.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  italic;
    font-weight: 400;
    src: url("https://rsms.me/inter/font-files/Inter-Italic.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Italic.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 500;
    src: url("https://rsms.me/inter/font-files/Inter-Medium.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Medium.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 600;
    src: url("https://rsms.me/inter/font-files/Inter-SemiBold.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-SemiBold.woff?v=3.11") format("woff");
  }
  @font-face {
    font-family: Inter;
    font-style:  normal;
    font-weight: 700;
    src: url("https://rsms.me/inter/font-files/Inter-Bold.woff2?v=3.11") format("woff2"),
         url("https://rsms.me/inter/font-files/Inter-Bold.woff?v=3.11") format("woff");
  }
  /* Modular scale with exponent 1.26, about 2^(1/3), so we get 2em in there,
     which is convenient. 1.26 is also close to (golden ratio)^0.5.
     0.63em
     0.80em
     1.00em
     1.26em
     1.59em
     2.00em
  */
  * { margin: 0; padding: 0; border-spacing: 0; }
  html {
    font-family: Inter, Roboto, sans-serif;
    /*
    Turn on character variant 8 for Inter, which puts serifs on the uppercase I.
    Also turn on variant 1, which has a curved 1.
    Disable contextual alternates for now. There is a bug, either in Inter or
    in Chrome (https://crbug.com/1046095) that causes colons after a <strong> to
    be raised above the baseline.
    */
    font-feature-settings: 'cv01' 1, 'cv08' 1, 'calt' 0;

    font-size: 16px;
    line-height: 1.59em;
    background-color: #fff;
    height: 100%;
  }
  body {
    height: 100%;
  }
  #content {
    display: grid;
    grid-template-columns: auto 16rem 50rem auto;
    color: #333;
    min-height: 100%;
  }
  #main {
    grid-area: 1 / 3 / 2 / 4;
    padding: 2rem;
    padding-left: 4rem;
    padding-right: 4rem;
    overflow: hidden;
  }
  #breadcrumbs {
    margin-bottom: 2.85rem;
    word-spacing: 0.3em;
    color: #78a;
  }
  #breadcrumbs a {
    word-spacing: 0;
    color: #78a;
  }
  article {
    margin-top: 1.3rem;
  }
  h1, h2, h3 {
    font-weight: 600;
    font-size: 1rem;
    color: #444;
    margin-bottom: 1.59rem;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 1.9rem;
  }
  h2 {
    font-size: 1.59rem;
    margin-top: 3.38rem;
    margin-bottom: 1.39rem;
  }
  code {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.84rem;
    line-height: 1.59rem;
  }
  h3 > code {
    /* Roboto Mono 500 is about as heavy as Inter semibold (600). */
    font-weight: 500;
  }
  abbr {
    text-transform: uppercase;
    /* Downsize so caps are x-height, and compensate weight loss. */
    font-size: 0.78rem;
    font-weight: 500;
    letter-spacing: 0.05rem;
  }
  sub, sup {
    /* Don't disturb the line height of normal text. */
    line-height: 0rem;
    font-size: 0.78rem;
    font-weight: 500;
  }
  p > code,
  a > code,
  h3 > code,
  li > code,
  td > code {
    background-color: #f0f0f0;
    padding: 0.13rem;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
    border-radius: 0.2rem;
    line-height: 1rem;
  }
  h3 {
    margin-top: 2.29rem;
    margin-bottom: 0.89rem;
  }
  h3 > code {
    margin-left: -0.1rem;
  }
  a {
    color: #36d;
    text-decoration: none;
  }
  p, ul, ol, pre, table {
    /* Same space as line height, leave exactly one line blank. */
    margin-bottom: 1.59em;
  }
  pre {
    padding: 1.41rem;
    padding-right: 0;
    background-color: #f8f8f8;
    border-radius: 0 0.2rem 0.2rem 0;
    border-left: 0.3rem solid #d5d8e0;
    overflow-x: auto;
  }
  pre > code {
    margin-right: 1.41rem;
    color: #555;
  }
  ul, ol {
    list-style-type: none;
    counter-reset: item;
  }
  table {
    font-variant-numeric: tabular-nums;
  }
  th, td {
    padding-right: 2rem;
  }
  th {
    text-align: left;
  }
  td > img {
    display: block;
    padding-top: 1em;
    padding-bottom: 1em;
  }
  #main ul li:before {
    color: #555;
    content: '\2022';
    display: inline-block;
    font-weight: 700;
    margin-left: -0.9rem;
    width: 0.9rem;
  }
  #main ul li {
    margin-left: 0.87rem;
  }
  #main ol li:before {
    content: counter(item);
    display: inline-block;
    font-weight: 700;
    width: 0.8rem;
    margin-left: -1.6rem;
    padding-right: 0.8rem;
  }
  #main ol li {
    margin-left: 1.6rem;
    counter-increment: item;
  }
  #nav-prev-next {
    margin-top: 3.18rem;
    padding-bottom: 3.18rem;
  }
  #nav-prev, #nav-next, #repo-link {
    display: inline-block;
  }
  #nav-prev {
    float: left;
  }
  #nav-next, #repo-link {
    float: right;
    text-align: right;
  }
  #nav-prev::before {
    content: '\219e';
    padding-right: 0.5em;
  }
  #nav-next::after {
    content: '\21a0';
    padding-left: 0.5em;
  }
  aside {
    grid-area: 1 / 1 / 2 / 3;
    border-right: 1px solid #eee;
    background-color: #fafafa;
  }
  aside nav {
    margin-top: 8.4rem;
    padding-bottom: 3rem;
    width: 14rem;
    float: right;
    /* Put the active chapter border over the sidebar border. */
    margin-right: -1px;
  }
  aside a {
    color: #78a;
  }
  aside .toc-section {
    font-weight: 700;
  }
  aside ul {
    margin-bottom: 0;
  }
  aside li ul {
    /* This padding destroys the vertical rhythm,
       but I somehow feel it is necessary. */
    padding-top: 0.3rem;
    padding-bottom: 0.4rem;
  }
  aside li.toc-section {
    padding-top: 1.59rem;
  }
  aside li.toc-section a {
    color: #36d;
  }
  aside li.current, aside li ul {
    border-right: 0.3em solid #d5d8e0;
    padding-left: 1em;
    margin-left: -1em;
  }
  aside .current a {
    font-weight: 600;
  }
  aside li.toc-heading {
    padding-left: 1em;
  }

  @media(max-width: 59.5rem)
  {
    #content {
      /* Manual implementation of max-width: on narrower viewports,
         auto-size the body. */
      grid-template-columns: 0 16rem auto 0;
    }
  }

  @media(max-width: 1150px)
  {
    html { font-size: 15px; }
  }

  /* Move the sidebar TOC below content at small widths. */
  @media(max-width: 800px)
  {
    #content {
      display: block;
    }
    aside {
      border-top: 1px solid #eee;
      border-right: 0px none;
    }
    aside nav {
      margin-left: 4em;
      margin-top: 1.59em;
      float: none;
    }
    #main {
      padding-bottom: 1.59em;
    }
    aside li.current, aside li ul {
      border-right: 0px none;
    }
  }

  /* Use less generous margins for very narrow viewports. */
  @media(max-width: 650px)
  {
    #main {
      padding-left: 2rem;
      padding-right: 2rem;
    }
    aside nav {
      margin-left: 2rem;
      padding-bottom: 2rem;
    }
  }

  @media(max-width: 450px)
  {
    #main {
      padding-left: 1.59em;
      padding-right: 1.59em;
    }
    aside nav {
      margin-left: 1.59em;
    }
  }
  </style>
</head>
<body>
  <div id="content">
    <div id="main">
      <nav id="breadcrumbs">
        <a href="..">Noblit</a>
        › <a href="..">Internals</a>
  › <a href="./">Query optimization</a>
  <a id="repo-link" href="https://github.com/ruuda/noblit/">GitHub</a>
      </nav>
      <article>
        <h1 id="query-optimization">Query optimization</h1>
<p>The order of statements in a query affect the query plan that Noblit chooses. As
outlined in the <a href="../query-planning/">Query planning</a> chapter, every statement
translates to a loop that scans over an index. The planner preserves statement
order: the first statement becomes the outer loop, the last statement becomes
the inner loop. Therefore, the statement order of the query can have a big
effect on query performance.</p>
<p>To help optimize the order of statements, Noblit features a query optimizer. The
optimizer is not part of the query planner. It is a standalone function that
takes a query and a database, and returns the optimized query.</p>
<p>There are two ways to optimize a query plan:</p>
<ul>
<li><strong>Optimizing statement order</strong>, also called <em>macro-optimization</em>, because
   statement order can make orders of magnitude difference in the evaluation
   time of a query. This is because statement order can make a difference in
   complexity, it can be the difference between a query plan that is quadratic
   in the size of an index, versus a query plan that is constant time. Statement
   order can be the difference between microseconds, and minutes.</li>
<li><strong>Choosing the indexes to use for a scan</strong>, also called <em>micro-optimization</em>,
   because so far empirical evidence suggests that the performance difference
   between the various indexes that can service a scan is small. This is because
   the indexes have the same complexity, it is only locality effects that make
   one index more suitable than another. The difference between the best and
   worst plan may be a factor two in extreme cases, but not an order of
   magnitude.</li>
</ul>
<p>Although the optimizer performs both macro and micro-optimization, currently the
indexes used can not be controlled by the query. Perhaps it would be best for
the optimizer to only consider plans that the planner generates.</p>
<h2 id="optimizing-statement-order">Optimizing statement order</h2>
<p>For a query with <em>n</em> statements, there are <em>n!</em> possible statement orders.
Trying every permutation quickly becomes prohibitive, especially because many
permutations lead to terrible query plans, so even trying each plan once can
take a long time. Fortunately, with some reasonable assumptions, it is possible
to find a good plan quickly.</p>
<p><strong>Assumption</strong>: Adding an extra statement at the end of a query,
can not make it faster.</p>
<p>This assumption is justified, because every statement translates to a scan over
an index, so adding a statement results in strictly more work.</p>
<p>With the above assumption, we can express statement order optimization as a tree
search problem. The root of the tree is an empty query, and along the branches
we include one more statement of the original query. Interior nodes of the tree
are <em>partial queries</em>, while the leaves form all permutations of the statements.
To find the optimal query plan is to pick the best leaf node, and the assumption
we made implies that the query time of a child node is larger than the query
time of the parent node.</p>
<p>Given the tree of partial queries, we can explore the tree to find the leaf with
the minimal query time. Because the query time of a child is greater than that
of the parent, we can call the additional time the “cost” of an edge, and
finding the leaf with the minimal query time means finding a path through the
tree with minimal cost. Dijkstra’s algorithm solves this neatly:</p>
<ul>
<li>Track an <em>open set</em> of candidate nodes.</li>
<li>Remove the candidate with the minimal query time from the open set, and add
   all of its children.</li>
<li>If the best candidate in the open set is a leaf node, then that is the
   optimal query plan.</li>
</ul>
<p>While this algorithm will find the optimal query plan, it is not obvious that it
will find it quickly. The algorithm might explore breadth-first, and explore
most of the tree before it reaches a leaf node. But in practice, this is not
what happens. Early on, there tend to be a few partial queries that are so bad
that they are worse than many leaf nodes. This cuts off entire branches of the
tree, and the algorithm reaches a leaf node quickly.</p>
<h2 id="optimizing-scans">Optimizing scans</h2>
<p>Some scans can be serviced by multiple indexes. For example, for a partial index
scan that finds the value of an attribute for a given entity, we could use
either <abbr>EAVT</abbr> or <abbr>AEVT</abbr>. For a given statement order, the
goal of scan optimization is to find the best index to use for each statement.</p>
<p>Unlike statement order optimization, there is no property that allows us to find
a good solution incrementally. Because of locality interactions between scans,
we need to consider the query plan as a whole.</p>
<p>The current approach is to just try all possibilities. It is exponential, but
not nearly as bad as permutations of statements. A statement can be serviced by
1, 2, or 3 possible indexes, so the number of options tends to be in the dozens,
which is quite doable.</p>
<p>This will surely blow up if you enter a ridiculously long query. Perhaps
deleting the micro-optimizer is the best remedy.</p>
<h2 id="explore-exploit">Explore-exploit</h2>
<p><em>This section has not been written yet. The gist of it is:</em></p>
<ul>
<li>Benchmarking is hard.</li>
<li>Take the minimum.</li>
<li>Justify min * (1 - 1/sqrt(n)) ordering.</li>
<li>Probablistic, so not shortest path, but no problem, we only want a good path.</li>
</ul>
      </article>
      <nav id="nav-prev-next">
        <a id="nav-prev" href="../execution/" title="Execution">Previous</a>
        </nav>
      </div>
    <aside>
      <nav>
        <ul>
        <li class="toc-section"><a href="..">Overview</a></li>
          <li class="toc-section"><a href="../data-model/">Concepts</a></li>
          <li class="toc-chapter
              "><a href="../data-model/">Data model</a></li>
            <li class="toc-chapter
              "><a href="../query/">Query</a></li>
            <li class="toc-chapter
              "><a href="../query-planning/">Query planning</a></li>
            <li class="toc-section"><a href="../examples/bug-tracker/">Examples</a></li>
          <li class="toc-chapter
              "><a href="../examples/bug-tracker/">Bug tracker</a></li>
            <li class="toc-section"><a href="../building/">Development</a></li>
          <li class="toc-chapter
              "><a href="../building/">Building</a></li>
            <li class="toc-chapter
              "><a href="../golden-tests/">Golden tests</a></li>
            <li class="toc-chapter
              "><a href="../resources/">Resources</a></li>
            <li class="toc-section"><a href="../files/">Internals</a></li>
          <li class="toc-chapter
              "><a href="../files/">Files</a></li>
            <li class="toc-chapter
              "><a href="../htree/">Trees</a></li>
            <li class="toc-chapter
              "><a href="../execution/">Execution</a></li>
            <li class="toc-chapter
               current"><a href="./">Query optimization</a></li>
            <li><ul>
                <li class="toc-heading"><a href="#optimizing-statement-order">Optimizing statement order</a></li>
                <li class="toc-heading"><a href="#optimizing-scans">Optimizing scans</a></li>
                <li class="toc-heading"><a href="#explore-exploit">Explore-exploit</a></li>
                </ul></li>
               </ul>
      </nav>
    </aside>
  </div>
</body>
</html>